---
layout:     post
title:      "Distributed unique key generation"
subtitle:   "如何分布式生成unique-key"
date:       2016-11-11 12:00:00
author:     "lanpay"
header-img: "img/post-bg-re-vs-ng2.jpg"
header-mask: 0.3
catalog:    true
tags:
    - unique key generation
    - distributed
    - engineer
---

在很多系统中，我们需要产生唯一的序列号unique key，用来作为id使用。常见的比如订单编号，付款码，数据库的主键等。本篇文章主要分析常见的生成unique key的场景和方法。


## 常见场景

### 数据库主键

我们在使用数据库时经常需要生成主键，这个主键一般来说最好和业务无关。比如你需要存一个城市列表，那么最好不要使用城市名称作为主键，一旦城市名发生变化，你不得不去修改相关的主键，这是很要命的；此外还很可能会存在名称相同的城市。我有一个朋友曾使用电话号码作为主键来存联系人，一开始完全没问题，直到有人想修改自己的电话号码，这完全就是一个灾难，你不得不去同时修改库里和该表做过关联的所有表的相关数据。

回到正题，我们希望生成业务无关的id，自增序列是一个不错的方案，几乎所有的sql都支持自增序列，并且它符合几乎所有需求---简单、易读、高效，除了无法分布式。对于一般的小型项目，单库能支撑的，它确实是一个不错的方案。

### 订单号

好吧，这里单独拿出一个小节写如此detail的东西，确实有点小题大做。但是不得不说，订单号是相当具有代表性的
一个unique key的应用。它不但很可能作为你的数据库主键，还很可能展示给你的客户看。想想看吧，如果使用自增序列，别人能清楚的看出贵系统的订单增长情况，并且很多情况下你的订单号里面有数不清的0，看上去十分不professional。你自然可以说，我给它做个映射，比如md5怎么样？那么你必须维护一个真实id，一个display-id，这毫无疑问增加了系统复杂性和出错的概率。

从另一方面来说，订单号对创建的需求是很大的，比如一旦到了双十一，各家电商上的订单将如雪片一般飘来，必然需要一个集群来处理每秒上万的订单请求，这就需要一个分布式的生成key的方案。


## 分布式unique key的生成方案

下面我将介绍几种常用的分布式unique key生成的解决方案。需要说明的是，并没有一种完美的解决方案，几种方案各有优劣，读者朋友需要体会其中的principle，选出适合自己的方案即可。


### Bson ObjectID

[Bson ObjectID](https://docs.mongodb.com/manual/reference/method/ObjectId/) 是mongoDB的unique key生成方案。一个典型的objectID如 *“4df2dcec2cdcd20936a8b817”*。 下图是它的结构：

![Bson-ObjectID](/img/in-post/bson-objectID.jpg)

它是一个十二字节的字符串，分为4段。
- 4字节长度的unix秒数；
- 3字节长度的机器码；
- 2字节长度的进程码；
- 3字节长度的计数器

time首先保证了时间上的唯一性；机器码和进程码保证了服务本身的唯一性；计数器保证了这一秒内的id是互斥的。。它的唯一性保障非常简单，这里不再做深入分析。

需要注意的是，它的机器码、进程码都是通过系统API自动获取的。因此我们容易看到，它最大的优势是轻量级，即我们不需要额外的配置或服务来生成ID。这实际上是一种空间换时间的手法，利用较大的空间简洁地构建出唯一序列。尤其是现在机器的内存和硬盘相对廉价的情况下，这不失为一种很有远见的做法！


### Snowflake

[Snowflake](https://github.com/twitter/snowflake) 是twitter的分布式id生成方案。

它同样是一个基于time的id生成方案，但是长度只有8个byte，也就是说只有64位，可以存入一个长整型。其结构如下图所示：
![snowflake](/img/in-post/snowflake-64bit.jpg)

除了最高位bit标记为不可用以外，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号（inc）支持1毫秒产生4095个自增序列id。

但是我们需要注意的是，snowflake的机器码并不是自动生成的，而是需要主动获取。既可以通过配置文件项获取，也可以通过某个调度中心获取。当机器很多时，用配置方式将会非常被动，因此最好还是通过建一个调度中心来专门分配机器码。

将twitter与mongo的设计做对比，我们能看到一个非常有意思的地方，mongo力求设计的简洁，twitter则追求极致的性能，这是一个通用库和一个专业场景方各自的立场。

## 实现注意事项

这里简单谈一下具体实现的一些细节和技巧。

### 无锁实现

使用锁，或者synchronize关键字来实现当然是最方便的。那么是否有无锁实现的方式呢？

无论是c++11，还是java，都提供了atomic操作，因此我们最好使用原子操作来做同步，而不是使用锁，以达到更快的速度。我们容易知道，竞争主要发生在相同time的操作内。假设时间按秒记，我们维护一个长度为10的数组（假设每次调用时间小于10s）；那么某次操作获得的time % 10就是其对应的参数下标。该操作只修改对应下标的参数而不影响其它的参数（即只和相同time内的做竞争）。这样就可以只使用atomic操作完成同步。

从另一个角度看，如果我们能确保inc不超，那么可以只保留一组参数，每次增加inc取模。不过这样做似乎并不保险。

### inc用完

由于inc长度有限，当某一time内的inc用完时，就需要等到下一个time再获取key。可以直接循环死等。



