---
layout:     post
title:      "Distributed unique key generation"
subtitle:   "如何分布式生成unique-key"
date:       2016-11-11 12:00:00
author:     "lanpay"
header-img: "img/post-bg-re-vs-ng2.jpg"
header-mask: 0.3
catalog:    true
tags:
    - unique key generation
    - distributed
    - engineer
---

在很多系统中，我们需要产生唯一的序列号unique key，用来作为id使用。常见的比如订单编号，付款码，数据库的主键等。本篇文章主要分析常见的生成unique key的场景和方法。


## 常见场景

### 数据库主键

我们在使用数据库时经常需要生成主键，这个主键一般来说最好和业务无关。比如你需要存一个城市列表，那么最好不要使用城市名称作为主键，一旦城市名发生变化，你不得不去修改相关的主键，这是很要命的；此外还很可能会存在名称相同的城市。我有一个朋友曾使用电话号码作为主键来存联系人，一开始完全没问题，直到有人想修改自己的电话号码，这完全就是一个灾难，你不得不去同时修改库里和该表做过关联的所有表的相关数据。

回到正题，我们希望生成业务无关的id，自增序列是一个不错的方案，几乎所有的sql都支持自增序列，并且它符合几乎所有需求---简单、易读、高效，除了无法分布式。对于一般的小型项目，单库能支撑的，它确实是一个不错的方案。

### 订单号

好吧，这里单独拿出一个小节写如此detail的东西，确实有点小题大做。但是不得不说，订单号是相当具有代表性的
一个unique key的应用。它不但很可能作为你的数据库主键，还很可能展示给你的客户看。想想看吧，如果使用自增序列，别人能清楚的看出贵系统的订单增长情况，并且很多情况下你的订单号里面有数不清的0，看上去十分不professional。你自然可以说，我给它做个映射，比如md5怎么样？那么你必须维护一个真实id，一个display-id，这毫无疑问增加了系统复杂性和出错的概率。

从另一方面来说，订单号对创建的需求是很大的，比如一旦到了双十一，各家电商上的订单将如雪片一般飘来，必然需要一个集群来处理每秒上万的订单请求，这就需要一个分布式的生成key的方案。


## 分布式unique key的生成方案

下面我将介绍几种常用的分布式unique key生成的解决方案。需要说明的是，并没有一种完美的解决方案，几种方案各有优劣，读者朋友需要体会其中的principle，选出适合自己的方案即可。


### Bson ObjectID

[Bson ObjectID](https://docs.mongodb.com/manual/reference/method/ObjectId/) 是mongoDB的unique key生成方案。一个典型的objectID如 *“4df2dcec2cdcd20936a8b817”*。 下图是它的结构：

![Bson-ObjectID](img/bson-objectID.jpg)

它是一个十二字节的字符串，分为4段。
- 4字节长度的unix秒数；
- 3字节长度的机器码；
- 2字节长度的进程码；
- 3字节长度的计数器

time首先保证了时间上的唯一性；机器码和进程码保证了服务本身的唯一性；计数器保证了这一秒内的id是互斥的。。它的唯一性保障非常简单，这里不再做深入分析。

需要注意的是，它的机器码、进程码都是通过系统API自动获取的。因此我们容易看到，它最大的优势是轻量级，即我们不需要额外的配置或服务来生成ID。这实际上是一种空间换时间的手法，利用较大的空间简洁地构建出唯一序列。尤其是现在机器的内存和硬盘相对廉价的情况下，这不失为一种很有远见的做法！

*** 注意2：在依赖关系中尽量做成树形结构，而不要产生circle，否则会报错。 ***

