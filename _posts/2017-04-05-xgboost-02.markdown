---
layout:     post
title:      "Xgboost 02"
subtitle:   "Xgboost02简介" 
date:       2017-04-06 12:00:00
author:     "lanpay"
header-img: "img/post-bg-re-vs-ng2.jpg"
header-mask: 0.3 
catalog:    true
tags:
    - akka
    - actor
    - engineer
---

### Iter流程

```cpp
  void UpdateOneIter(int iter, DMatrix* train) override {
    CHECK(ModelInitialized())
        << "Always call InitModel or LoadModel before update";
    if (tparam.seed_per_iteration || rabit::IsDistributed()) {
      common::GlobalRandom().seed(tparam.seed * kRandSeedMagic + iter);
    }
    this->LazyInitDMatrix(train); // 初始化DMatrix
    this->PredictRaw(train, &preds_); // 获得已有模型的预测值
    obj_->GetGradient(preds_, train->info(), iter, &gpair_); // 计算loss的一阶和二阶梯度
    gbm_->DoBoost(train, &gpair_, obj_.get()); // 构造一颗新的树
  }
```

- *UpdateOneIter*
主要调用了*gbm_->DoBoost*；


- *DoBoost*
主要调用了*BoostNewTrees*；

- *BoostNewTrees*
主要调用了*TreeUpdater->Update*；
默认情况下会有两个TreeUpdater，一个是*grow_colmaker*，负责种树的叶子；另一个是*prune*，负责剪枝。


colmaker的Update函数如下
```cpp
virtual void Update(const std::vector<bst_gpair>& gpair,
                        DMatrix* p_fmat,
                        RegTree* p_tree) {
      this->InitData(gpair, *p_fmat, *p_tree);
      this->InitNewNode(qexpand_, gpair, *p_fmat, *p_tree);
      for (int depth = 0; depth < param.max_depth; ++depth) {
        this->FindSplit(depth, qexpand_, gpair, p_fmat, p_tree);
        this->ResetPosition(qexpand_, p_fmat, *p_tree);
        this->UpdateQueueExpand(*p_tree, &qexpand_);
        this->InitNewNode(qexpand_, gpair, *p_fmat, *p_tree);
        // if nothing left to be expand, break
        if (qexpand_.size() == 0) break;
      }
      // set all the rest expanding nodes to leaf
      for (size_t i = 0; i < qexpand_.size(); ++i) {
        const int nid = qexpand_[i];
        (*p_tree)[nid].set_leaf(snode[nid].weight * param.learning_rate);
      }
      // remember auxiliary statistics in the tree node
      for (int nid = 0; nid < p_tree->param.num_nodes; ++nid) {
        p_tree->stat(nid).loss_chg = snode[nid].best.loss_chg;
        p_tree->stat(nid).base_weight = snode[nid].weight;
        p_tree->stat(nid).sum_hess = static_cast<float>(snode[nid].stats.sum_hess);
        snode[nid].stats.SetLeafVec(param, p_tree->leafvec(nid));
      }
    }
```

（未完待续）

